# -*- coding: utf-8 -*-
"""
Created on Thu Oct 20 10:42:05 2022

@author: ss38
"""
from numpy.linalg import inv
import numpy as np
import magpylib as magpy
import matplotlib.pyplot as plt
from itertools import chain
from scipy.signal import find_peaks,peak_widths
import scipy.constants as constant
from scipy.special import ellipk,ellipe
import math
import seaborn as sns

def B_1ykl(x_k, x_l, l_a, l_b, z_k, y_k, y_l):
    # Magnetic Field in the y direction of first wire
    dprime = x_k - (x_l - l_a)  # Distance between axis and probe point along the wire
    ddoubleprime = (x_l + l_a) - x_k  # Distance between probe point and end of the wire on wire axis
    a_kl = np.sqrt((y_k -(y_l - l_b))**2 + z_k**2)  # Distance from point to wire perpendicular to wire axis
    aprime_1kl = np.sqrt(a_kl**2 + dprime**2)  # Total distance from start of wire position to probe point
    adoubleprime_1kl = np.sqrt(a_kl**2 + ddoubleprime**2)  # Total distance from end of wire position to probe point
    B_1kl = (constant.mu_0*((dprime/aprime_1kl) + (ddoubleprime/adoubleprime_1kl)))/(4*np.pi*a_kl)  # Total field generated by Wire 1
    B_1ykl = -B_1kl * (z_k/a_kl)  # Y component of Total field
    return B_1ykl


def B_1zkl(x_k, x_l, l_a, l_b, z_k, y_k, y_l):
    # Magnetic Field of wire 1 in z direction
    dprime = x_k - (x_l - l_a)  # Distance between axis and probe point along the wire
    ddoubleprime = (x_l + l_a) - x_k  # Distance between probe point and end of the wire on wire axis
    a_kl = np.sqrt((y_k -(y_l - l_b))**2 + z_k**2) # Distance from point to wire perpendicular to wire axis
    aprime_1kl = np.sqrt(a_kl**2 + dprime**2)  # Total distance from start of wire position to probe point
    adoubleprime_1kl = np.sqrt(a_kl**2 + ddoubleprime**2)  # Total distance from end of wire position to probe point
    B_1kl = (constant.mu_0*((dprime/aprime_1kl) + (ddoubleprime/adoubleprime_1kl)))/(4*np.pi*a_kl)  # Total field generated by Wire 1
    B_1zkl = (B_1kl)*((y_k - (y_l - l_b))/a_kl)  # Z component of Total field
    return B_1zkl


def B_2ykl(x_k,x_l,l_a,l_b,z_k,y_k,y_l):
    #Magnetic field of wire 2 in y direction, wire 2 is in the same plane as wire 1 but opposite direction
    dprime = x_k - (x_l + l_a)#Distance between axis and probe point along the wire
    ddoubleprime = (x_l - l_a) - x_k #Distance between probe point and end of the wire on wire axis
    a_kl = np.sqrt((y_k -(y_l + l_b))**2 + z_k**2) #Distance from point to wire perpendicular to wire axis
    aprime_1kl = np.sqrt(a_kl**2 + dprime**2)#Total distance from start of wire position to probe point
    adoubleprime_1kl = np.sqrt(a_kl**2 + ddoubleprime**2)#Total distance from end of wire position to probe point
    B_2kl = (constant.mu_0*((dprime/aprime_1kl) + (ddoubleprime/adoubleprime_1kl)))/(4*np.pi*a_kl)#Total field generated by Wire 2
    B_2ykl = -(B_2kl)*(z_k/a_kl) #Y component of Total field
    return B_2ykl


def B_2zkl(x_k,x_l,l_a,l_b,z_k,y_k,y_l):
    # Magnetic field of wire 2 in z direction
    dprime = x_k - (x_l + l_a)  # Distance between axis and probe point along the wire
    ddoubleprime = (x_l - l_a) - x_k  # Distance between probe point and end of the wire on wire axis
    a_kl = np.sqrt((y_k - (y_l + l_b))**2 + z_k**2)  # Distance from point to wire perpendicular to wire axis
    aprime_1kl = np.sqrt(a_kl**2 + dprime**2)  # Total distance from start of wire position to probe point
    adoubleprime_1kl = np.sqrt(a_kl**2 + ddoubleprime**2)  # Total distance from end of wire position to probe point
    B_2kl = (constant.mu_0*((dprime/aprime_1kl) + (ddoubleprime/adoubleprime_1kl)))/(4*np.pi*a_kl)  # Total field generated by Wire 2
    B_2zkl = (B_2kl)*((y_k - (y_l + l_b))/a_kl)  # Z component of Total field
    return B_2zkl


def B_3xkl(x_k,x_l,l_a,l_b,z_k,y_k,y_l):
    #Magnetic field of wire 3 perpendicular to wire 1 and 2 in the x direction
    dprime = y_k - (y_l + l_b) #Distance between axis and probe point along the wire
    ddoubleprime = (y_l - l_b) - y_k  #Distance between probe point and end of the wire on wire axis
    a_kl = np.sqrt((x_k -(x_l - l_a))**2 + z_k**2) #Distance from point to wire perpendicular to wire axis
    aprime_1kl = np.sqrt(a_kl**2 + dprime**2) #Total distance from start of wire position to probe point
    adoubleprime_1kl = np.sqrt(a_kl**2 + ddoubleprime**2) #Total distance from end of wire position to probe point
    B_3kl = (constant.mu_0*((dprime/aprime_1kl) + (ddoubleprime/adoubleprime_1kl)))/(4*np.pi*a_kl)  #Total field generated by Wire 3
    B_3xkl = (B_3kl)*(z_k/a_kl) #X component of Total field
    return B_3xkl


def B_3zkl(x_k,x_l,l_a,l_b,z_k,y_k,y_l):
    #Magnetic field of wire 3 perpendicular to wire 1 and 2 in the x direction
    dprime = y_k - (y_l + l_b) #Distance between axis and probe point along the wire
    ddoubleprime = (y_l - l_b) - y_k #Distance between probe point and end of the wire on wire axis
    a_kl = np.sqrt((x_k -(x_l - l_a))**2 + z_k**2) #Distance from point to wire perpendicular to wire axis
    aprime_1kl = np.sqrt(a_kl**2 + dprime**2) #Total distance from start of wire position to probe point
    adoubleprime_1kl = np.sqrt(a_kl**2 + ddoubleprime**2)#Total distance from end of wire position to probe point
    B_3kl = (constant.mu_0*((dprime/aprime_1kl) + (ddoubleprime/adoubleprime_1kl)))/(4*np.pi*a_kl) #Total field generated by Wire 3
    B_3zkl = -(B_3kl)*((x_k - (x_l - l_a))/a_kl) #Z component of Total field
    return B_3zkl


def B_4xkl(x_k,x_l,l_a,l_b,z_k,y_k,y_l):
    #Magnetic field of wire 4 perpendicular to wire 1 and 2 in the x direction
    dprime = y_k - (y_l - l_b) #Distance between axis and probe point along the wire
    ddoubleprime = (y_l + l_b) - y_k #Distance between probe point and end of the wire on wire axis
    a_kl = np.sqrt((x_k -(x_l + l_a))**2 + z_k**2) #Distance from point to wire perpendicular to wire axis
    aprime_1kl = np.sqrt(a_kl**2 + dprime**2) #Total distance from start of wire position to probe point
    adoubleprime_1kl = np.sqrt(a_kl**2 + ddoubleprime**2) #Total distance from end of wire position to probe point
    B_4kl = (constant.mu_0*((dprime/aprime_1kl) + (ddoubleprime/adoubleprime_1kl)))/(4*np.pi*a_kl) #Total field generated by Wire 4
    B_4xkl = (B_4kl)*(z_k/a_kl) #X component of Total field
    return B_4xkl


def B_4zkl(x_k,x_l,l_a,l_b,z_k,y_k,y_l):
    #Magnetic field of wire 4 perpendicular to wire 1 and 2 in the z direction
    dprime = y_k - (y_l - l_b) #Distance between axis and probe point along the wire
    ddoubleprime = (y_l + l_b) - y_k #Distance between probe point and end of the wire on wire axis
    a_kl = np.sqrt((x_k - (x_l + l_a))**2 + z_k**2) #Distance from point to wire perpendicular to wire axis
    aprime_1kl = np.sqrt(a_kl**2 + dprime**2) #Total distance from start of wire position to probe point
    adoubleprime_1kl = np.sqrt(a_kl**2 + ddoubleprime**2) #Total distance from end of wire position to probe point
    B_4kl = (constant.mu_0*((dprime/aprime_1kl) + (ddoubleprime/adoubleprime_1kl)))/(4*np.pi*a_kl) #Total field generated by Wire 4
    B_4zkl = -(B_4kl)*((x_k - (x_l + l_a))/a_kl) #Z component of Total field
    return B_4zkl


def A_xkl(x_k, x_l, l_a, l_b, z_k, y_k, y_l):
    # Total Sum of Magnetic Field Wire Components in the x direction where I is removed as a matrix multiplication
    #BX = Axkl*I
    Axkl = B_3xkl(x_k, x_l, l_a, l_b, z_k, y_k, y_l) + B_4xkl(x_k, x_l, l_a, l_b, z_k, y_k, y_l)
    return Axkl


def A_ykl(x_k, x_l, l_a, l_b, z_k, y_k, y_l):
    #Total Sum of Magnetic Field Wire Components in the y direction where I is removed as a matrix multiplication
    #BY = Aykl*I
    Aykl = B_1ykl(x_k, x_l, l_a, l_b, z_k, y_k, y_l) + B_2ykl(x_k, x_l, l_a, l_b, z_k, y_k, y_l)
    return Aykl


def A_zkl(x_k, x_l, l_a, l_b, z_k, y_k, y_l):
    #Total Sum of Magnetic Field Wire Components in the z direction where I is removed as a matrix multiplication
    #BZ = Azkl*I
    Azkl = B_1zkl(x_k, x_l, l_a, l_b, z_k, y_k, y_l) + B_2zkl(x_k, x_l, l_a, l_b, z_k, y_k, y_l) + B_3zkl(x_k, x_l, l_a, l_b, z_k, y_k, y_l) + B_4zkl(x_k, x_l, l_a, l_b, z_k, y_k, y_l) 
    #print(B_1zkl(x_k, x_l, l_a, l_b, z_k, y_k, y_l), B_2zkl(x_k, x_l, l_a, l_b, z_k, y_k, y_l))
    
    #fig=plt.figure()
    #ax=fig.add_subplot(111)
    #ax.plot(B_1zkl(x_k, x_l, l_a, l_b, z_k, y_k, y_l))
    #ax.plot(B_2zkl(x_k, x_l, l_a, l_b, z_k, y_k, y_l))
    
    return Azkl


def Position_Tensor_square(observer_position, wire_position, separation, l_a, l_b):
    # Determines the individual Ax, Ay, Az matrices which determines the magnetic field at every position due to every wire component
    # Initialise x, y and z lists before stacking them vertically
    a_xmatrix = []
    a_ymatrix = []
    a_zmatrix = []
    for i in range(len(observer_position)):
        # For each observer position find the magnetic field from each wire and add them to the list
        new_rowx = []
        new_rowy = []
        new_rowz = []
        for j in range(len(wire_position)):
            # Add all the contributions from each wire position from each observer position
            #print(observer_position[0][0], observer_position[i][1])
            new_rowx.append(A_xkl(observer_position[i][0], wire_position[j][0], l_a, l_b, separation, observer_position[i][1], wire_position[j][1]))
            new_rowy.append(A_ykl(observer_position[i][0], wire_position[j][0], l_a, l_b, separation, observer_position[i][1], wire_position[j][1]))
            new_rowz.append(A_zkl(observer_position[i][0], wire_position[j][0], l_a, l_b, separation, observer_position[i][1], wire_position[j][1]))                
        a_xmatrix.append(new_rowx)
        a_ymatrix.append(new_rowy) 
        a_zmatrix.append(new_rowz) 
    # Turn lists into matrices so they can be stacked
    np.array(a_xmatrix)
    np.array(a_ymatrix)
    np.array(a_zmatrix)
    # Vertical stacking of the matrices for x, y and z components
    A = np.vstack((a_xmatrix, a_ymatrix, a_zmatrix))
    a_xmatrix = np.array(a_xmatrix)
    a_ymatrix = np.array(a_ymatrix)
    a_zmatrix = np.array(a_zmatrix)
    #a_zmatrix=0
    #print(a_zmatrix)
    #print(A, a_xmatrix, a_ymatrix, a_zmatrix)
    return A, a_xmatrix, a_ymatrix, a_zmatrix


#Circular coil definitions now
x = lambda xk, xl: xk-xl #Absolute distance x
y = lambda yk,yl: yk- yl #Absolute distance y
r = lambda xk,xl,yk,yl,z: np.sqrt(x(xk,xl)**2 + y(yk,yl)**2 + z**2) #Absolute total distance
rho = lambda xk,xl,yk,yl: np.sqrt(x(xk,xl)**2 + y(yk,yl)**2) #Absolute distance in the x,y plane
al = lambda xk,xl,yk,yl,z,a: np.sqrt(a**2 + r(xk,xl,yk,yl,z)**2 -(2*a*rho(xk,xl,yk,yl)))
be = lambda xk,xl,yk,yl,z,a: np.sqrt(a**2 + r(xk,xl,yk,yl,z)**2 + (2*a*rho(xk,xl,yk,yl)))
k = lambda xk,xl,yk,yl,z,a: np.sqrt( 1 - (al(xk,xl,yk,yl,z,a)**2/be(xk,xl,yk,yl,z,a)**2))
E = lambda xk,xl,yk,yl,z,a: ellipe(k(xk,xl,yk,yl,z,a)**2)
K = lambda xk,xl,yk,yl,z,a: ellipk(k(xk,xl,yk,yl,z,a)**2)
C = constant.mu_0/np.pi

def A_cxkl(xk,xl,yk,yl,z,a):
    #Magnetic Bx field component Bx = Ax*I, where individual component Ax
    A = ((C*x(xk,xl)*z)/(2*(al(xk,xl,yk,yl,z,a)**2)* be(xk,xl,yk,yl,z,a)*(rho(xk,xl,yk,yl)**2))) * ((a**2 + r(xk,xl,yk,yl,z)**2)*E(xk,xl,yk,yl,z,a) - (al(xk,xl,yk,yl,z,a)**2 * K(xk,xl,yk,yl,z,a)))
    if math.isnan(A):
        #Limiting case, where position is on axis
        A = 0
    return A


def A_cykl(xk,xl,yk,yl,z,a):
    #Magnetic By field component By = Ay*I, where individual component Ay
    A =  ((C*y(yk,yl)*z)/(2*(al(xk,xl,yk,yl,z,a)**2)* be(xk,xl,yk,yl,z,a)*(rho(xk,xl,yk,yl)**2)))  * ((a**2 + r(xk,xl,yk,yl,z)**2)*E(xk,xl,yk,yl,z,a) - (al(xk,xl,yk,yl,z,a)**2 * K(xk,xl,yk,yl,z,a)))
    if math.isnan(A):
        #Limiting case, where position is on axis
        A = 0
    return A


def A_czkl(xk,xl,yk,yl,z,a):
    #Magnetic Bz field component Bz = Az*I, where individual component Az

    A = (C/(2*(al(xk,xl,yk,yl,z,a)**2)*be(xk,xl,yk,yl,z,a))) * ((a**2 - r(xk,xl,yk,yl,z)**2)*E(xk,xl,yk,yl,z,a) + (al(xk,xl,yk,yl,z,a)**2 * K(xk,xl,yk,yl,z,a)))
    if math.isinf(A):
        #Limiting case, where position is on axis
        A = (constant.mu_0*a**2)/(2*(a**2 + z**2)**1.5)
    return A


#A matrix producer so that B = AI can be sufficed 
def Position_Tensor(observer_position,wire_position,separation,a):
    #Determines the individual Ax,Ay,Az matrices which determines the magnetic field at every position due to every wire component
    #Initialise x,y and z lists before stacking them vertically
    a_xmatrix = []
    a_ymatrix = []
    a_zmatrix = []
    for i in range(len(observer_position)):
        #For each observer position find the magnetic field from each wire and add them to the list

        new_rowx = []
        new_rowy = []
        new_rowz = []
        for j in range(len(wire_position)):
            #Add all the contributions from each wire position from each observer position

            new_rowx.append(A_cxkl(observer_position[i][0], wire_position[j][0], observer_position[i][1], wire_position[j][1], separation, a))
            new_rowy.append(A_cykl(observer_position[i][0], wire_position[j][0], observer_position[i][1], wire_position[j][1], separation, a))
            new_rowz.append(A_czkl(observer_position[i][0], wire_position[j][0], observer_position[i][1], wire_position[j][1], separation, a))
            
        a_xmatrix.append(new_rowx)
        a_ymatrix.append(new_rowy) 
        a_zmatrix.append(new_rowz) 

    #Turn lists into matrices so they can be stacked
    np.array(a_xmatrix)
    np.array(a_ymatrix)
    np.array(a_zmatrix)
    #Vertical stacking of the matrices for x,y and z components

    A = np.vstack((a_xmatrix, a_ymatrix, a_zmatrix))
    a_xmatrix = np.array(a_xmatrix)
    a_ymatrix = np.array(a_ymatrix)
    a_zmatrix = np.array(a_zmatrix)
    return A, a_xmatrix, a_ymatrix, a_zmatrix


#Matrix calculation using Choi I = At(AAt)^-1B
def current_finder(A,B):
    #Matrix calculation using Choi I = (At(AAt)^-1)*B
    D = inv(np.matmul(A, A.transpose()))
    #C = np.matmul(D, B)
    #print(B)
    #current = np.matmul(A.transpose(), C)
    
    C = np.matmul(A.transpose(), D)
    #print(B)
    current = np.matmul(C, B)
    return current


# Defines centre of the coil position for an array of coils
def Position_definer(n1,n2,a,sep):
    # Sets up a grid of points centred in the origin. If the grid is odd, then middle coil is in the origin.
    # If the grid is even then between middle coils is the origin.
    sep = 0E-9 # Added speration between the points
    
    if ((n1*n2) % 2) != 0:
        # If there are two odd coil array lengths
        midval1 = math.floor(n1/2)
        midval2 = math.floor(n2/2)
        Matrix = [[[0 + 2*a*(x-midval1), 0 + 2*a*(y-midval2)] for x in range(n1)] for y in range(n2)]
        pointlist = list(chain.from_iterable(Matrix))
        #print(midval1, midval2, pointlist)

    else:
       # If there is at least one even coil number array
       if (n1 % 2) == 0:
           midval1 = (n1/2) - 0.5
       if (n1 % 2) != 0: 
           midval1 = math.floor(n1/2)
       if (n2 % 2) == 0: 
           midval2 = (n2/2) - 0.5   
       if (n2 % 2) != 0: 
           midval2 = math.floor(n2/2)  
           # Add pointlist in range of length of the array to be setup
    Matrix = [[[0 + 2*a*(x-midval1), 0 + 2*a*(y-midval2)] for x in range(n1)] for y in range(n2)]
    pointlist = list(chain.from_iterable(Matrix))    
    #print('pointlist', pointlist)
    return pointlist


def Bfield(new_observer_position, wire_position, separation, a, I, shape, l_a, l_b):
    #Returns the magnetic field of a square or circular setup embedded within
    if shape =='circular':
        # Creates the matrix field for a circular coil
        An, A_nx, A_ny, A_nz = Position_Tensor(new_observer_position, wire_position, separation, a)
    if shape =='square':
        # Creates the matrix field for a square coil
        An, A_nx, A_ny, A_nz = Position_Tensor_square(new_observer_position, wire_position, separation, l_a, l_b)
    # Magnetic Field calculation of matrix elements and current
    Bfield = (np.matmul(An, I))  # Total Field generated
    Bx = (np.matmul(A_nx, I))  # Bx field of the matrix elements
    By = (np.matmul(A_ny, I))  # By field of the matrix elements
    Bz = (np.matmul(A_nz, I))  # Bz field of the matrix elements
    #print(Bfield, Bx, By, Bz)
    #print(Bz)
    return Bfield, Bx, By, Bz
    

def Bfield_plotter(Bfield, observer_position, axis, separation):
    #2D Plotting of Magnetic field, axis refers to the Magnetic field direction
    if axis == 'x': 
        Bfieldchoice = Bfield[0:int(len(Bfield)/3)]
    if axis == 'y':
        Bfieldchoice = Bfield[int(len(Bfield)/3):2*int(len(Bfield)/3)]
    if axis == 'z':
        Bfieldchoice = Bfield[-int(len(Bfield)/3):]
    if axis == 'norm':
        Bfieldchoice = []
        for i in range(int(len(Bfield)/3)):
            Bfieldchoice.append(np.sqrt(Bfield[i]**2 + Bfield[int(i+(len(Bfield)/3))]**2 + Bfield[i + 2*int(len(Bfield)/3)]**2))
    #Magnetic field needs to be reshaped based on the number of points used in this case 100 x 100
    
    len_observer_position = round(np.sqrt(len(observer_position)))
    two_D = np.reshape(Bfieldchoice, (len_observer_position, len_observer_position))
    change_list = [tuple(elem) for elem in observer_position]
    my_dict = dict(zip(change_list,list(Bfieldchoice)))
    
    #print(abs(two_D))
        
    fig = plt.figure()
    ax = fig.add_subplot(111)
    c = ax.imshow(abs(two_D), extent=[observer_position[0][0], observer_position[round(len(observer_position)-1)][1], observer_position[0][0], observer_position[round(len(observer_position)-1)][1]])
    #ax.scatter([0],[0], s=2, color='tab:cyan')
    #x_interest = 10E-2/4
    #y_interest = 0#-10E-2/4
    #ax.scatter([x_interest], [y_interest], label='Rx max', marker='*', s=50, color='black')
    #print(np.transpose(observer_position)[1][round(len(observer_position)-1)], np.transpose(observer_position)[0][round(len(observer_position)-1)])
    #xlabels = ['{:3.1f}'.format(x) for x in np.transpose(observer_position)[0]]
    #ylabels = ['{:3.1f}'.format(y) for y in np.transpose(observer_position)[1]]
    #ax = sns.heatmap(two_D, xticklabels=xlabels, yticklabels=ylabels)
    #ax = sns.heatmap(two_D, xticklabels=A1, yticklabels=A2)
    #ax.set_xticks(ax.get_xticks()[::3])
    #ax.set_xticklabels(xlabels[::3])
    #ax.set_yticks(ax.get_yticks()[::3])
    #ax.set_yticklabels(ylabels[::3])
    ax.set_xlabel('$x$-position in Rx plane (m)')
    ax.set_ylabel('$y$-position in Rx plane (m)')
    fig.colorbar(c, ax=ax, label='Magnetic field magnitude (T)')
    #ax.set_xticks()
    ax.set_title('B{} heatmap with {:.1f}mm liftoff'.format(axis, separation*1000))
    #fig.show()

    row_of_interest = 50 # 44 for one coil or 49 for all coils
    #print(len(two_D))
    
    fig2 = plt.figure()
    ax2 = fig2.add_subplot(111)
    ax2.plot(np.linspace(observer_position[0][0], observer_position[round(len(observer_position)-1)][1], len_observer_position), two_D[row_of_interest])
    #np.savetxt(r'P:\Coldatom\LucasRushton\COMSOL\FieldFocussing\240326_SingleCoilRFField\Python_SingleCoil_10A_LF8mm_pos.txt', np.linspace(observer_position[0][0], observer_position[round(len(observer_position)-1)][1], len_observer_position))
    #np.savetxt(r'P:\Coldatom\LucasRushton\COMSOL\FieldFocussing\240326_SingleCoilRFField\Python_SingleCoil_10A_LF8mm_Bz.txt', two_D[row_of_interest])
    #np.savetxt(r'P:\Coldatom\LucasRushton\COMSOL\FieldFocussing\240326_11CoilsFieldFocussing\Python_121Coils_LF8mm_pos.txt', np.linspace(observer_position[0][0], observer_position[round(len(observer_position)-1)][1], len_observer_position))
    #np.savetxt(r'P:\Coldatom\LucasRushton\COMSOL\FieldFocussing\240326_11CoilsFieldFocussing\Python_121Coils_LF8mm_Bz.txt', two_D[row_of_interest])

    ax2.grid()
    ax2.set_xlabel('$x$-position in Rx plane (m)')
    ax2.set_ylabel('Magnetic field amplitude (T)')
    peaks,_ = find_peaks(two_D[row_of_interest])
    #ax2.plot(np.arange(observer_position[0][0], observer_position[round(len(observer_position)-1)][1], (observer_position[round(len(observer_position)-1)][1]-observer_position[0][0])/len(two_D[row_of_interest]))[peaks], two_D[row_of_interest][peaks],'x')
    #print(np.linspace(observer_position[0][0], observer_position[round(len(observer_position)-1)][1], 100), len(np.linspace(observer_position[0][0], observer_position[round(len(observer_position)-1)][1], 100)))
    #print(two_D[row_of_interest][peaks])
    #print(two_D[row_of_interest][peaks])
    #ax2.plot([0], two_D[row_of_interest][peaks],'x')

    results_half = peak_widths(two_D[row_of_interest], peaks, rel_height = 0.5)
    #print(observer_position[0][0], observer_position[round(len(observer_position)-1)][1], len_observer_position)
    #print(results_half)
    
    left_position = np.array([np.linspace(observer_position[0][0], observer_position[round(len(observer_position)-1)][1], len_observer_position)[round(x)] for x in results_half[2]])
    right_position = np.array([np.linspace(observer_position[0][0], observer_position[round(len(observer_position)-1)][1], len_observer_position)[round(x)] for x in results_half[3]])
    
    #print(int(66.8279))
    #print(left_position, right_position)
    #print((right_position - left_position))
    #print((left_position))
    #print((left_position))
    if len(right_position) == 1:
        peak_of_interest = 0 # 0 for one coil, 1 for all coils
    elif len(right_position) == 3:
        peak_of_interest = 1
    elif len(right_position) == 5:
        peak_of_interest = 2
    elif len(right_position) == 7:
        peak_of_interest = 3
    else:
        print('Number of peaks:', len(right_position))
    ax2.set_title('Liftoff = %smm' % round(1000*separation, 1))
    ax2.hlines(results_half[1], left_position, right_position, color="C5", label='FWHM=%smm' % (round(right_position[peak_of_interest]-left_position[peak_of_interest]*1000, 2)))
    print('FWHM of peaks', right_position-left_position)
    fwhm = right_position - left_position
    ax2.legend()
    return my_dict, fwhm
